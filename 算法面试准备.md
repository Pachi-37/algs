# 算法面试准备

快速排序算法 `O(nlogn)`

##### 数据存在的特征

- 包含大量重复元素
  - 三路排序
- 数据是否近乎有序——银行按时间排序
  - 插入排序
- 数据的取值范围有限——学生成绩
  - 计数排序

##### 要求

- 稳定性
  - 归并排序



##### 算法优化的思路

- 遍历常见的算法思路 
- 遍历常见的数据结构
- 空间换时间（哈希表）
- 预处理（排序）



### 算法时间复杂度

算法的时间复杂度通常是看最差情况来决定的

算法复杂度是用来表示算法性能变化趋势的，所以常数值不重要



### 数据规模的概念

如果想在 `1s` 内解决问题

- `O(n^2)` `10^4`级别数据
- `O(n)` `10^8` 级别数据
- `O(nlogn)` `10^7` 级别数据



##### 循环不变量

在每一轮算法开始时的满足的条件

- 查早算法 `data[i]`
  - `data[0,i]` 中都没找到目标（循环不变量） 

> 循环体：维持循环不变量，如果循环不变量发生改变，那么循环状态将会改变



# 基础排序算法



### 选择排序法

依次将最小的元素取出

```java
	// 借助额外空间实现
	public Integer[] sort(Integer[] data) {

        Integer[] sortedArr = new Integer[data.length];
        int minIndex = 0;

        for (int i = 0; i < sortedArr.length; i++) {
            minIndex = 0;
            for (int j = 1; j < data.length; j++) {
                if (data[minIndex].intValue() > data[j].intValue()) {
                    minIndex = j;
                    break;
                }
            }

            sortedArr[i] = data[minIndex];
            data = compact(data, minIndex);
        }

       return sortedArr;
    }

    private Integer[] compact(Integer[] data, int index) {
        Integer[] compactedArr = new Integer[data.length - 1];
        int cur = 0;

        for (int i = 0; i < index; i++) {
            if (index != i) {
                compactedArr[i] = data[cur++];
            }
        }

        for (int i = index; i < compactedArr.length; i++) {
            index++;
            compactedArr[i] = data[index];
        }

        return compactedArr;
    }

	// 原地排序实现
	public void sort(int[] data) {
        int minIndex = 0;

        for (int i = 0; i < data.length; i++) {
    	    minIndex = i;
        for (int j = i + 1; j < data.length; j++) {
            if (data[minIndex] > data[j]){
                minIndex = j;
            }
            swap(data,i,minIndex);
        }
    }
```

> 使用带约束的泛型来扩展使用范围：
>
> 实现 `<E extends Comparable<E>>`



##### 使用泛型优化代码

```java
 public static <E extends Comparable<E>> void sort(E[] arr) {

        // 选择排序循环不变量为 arr[i..n)未排序 arr[0..i) 已排序
//        for (int i = 0; i < arr.length; i++) {
//
//            // 选择 arr[i..)中最小值的索引
//            int minIndex = i;
//
//            for (int j = i; j < arr.length; j++) {
//                if (arr[j].compareTo(arr[minIndex]) < 0) {
//                    minIndex = j;
//                }
//            }
//
//            swap(arr, i, minIndex);
//        }
        // 选择排序循环不变量为 arr[i..n)已排序 arr[0..i)未排序
        for (int i = arr.length - 1; i > -1; i--) {

            int maxIndex = i;

            for (int j = i; j > -1; j--) {
                if (arr[j].compareTo(arr[maxIndex]) > 0) {
                    maxIndex = j;
                }
            }
            swap(arr, i, maxIndex);
        }
    }
```



### 检验排序工具

```java
public class SortingHelper {

    private SortingHelper() {
    }

    public static <E extends Comparable<E>> boolean isSorted(E[] arr) {

        for (int i = 0; i < arr.length - 1; i++) {
            if (arr[i].compareTo(arr[i + 1]) > 0) {
                return false;
            }
        }
        return true;
    }

    public static <E extends Comparable<E>> void sortTest(String sortName, E[] arr) {

        long startTime = System.nanoTime();

        if (sortName.equals("SelectionSort")) {
            SelectionSort.sort(arr);
        }

        long endTime = System.nanoTime();

        double time = (endTime - startTime) / 1000000000.0;

        if (!SortingHelper.isSorted(arr)) {
            throw new RuntimeException(sortName + " failed");
        }

        System.out.println(String.format("%s , n = %d : %f s", sortName, arr.length, time));
    }
}

```



### 插入排序

每次只处理一个元素，将该元素插入到前面已经排好序的元素中 

> 插入排序永远处理的是之前的元素，它和选择排序法不同：选择排序法处理的元素之后就是元素最终所在的位置



两种不同是实现方式

* 新的元素和已排序的元素依次比较，和比其大的元素依次交换位置
* 找到新元素的待插入点，将元素直接插入



> 插入排序法对于近乎有序的元素进行排序的时间复杂度为 `O(n)`，而对于选择排序法的算法复杂度永远为 O(n<sup>2</sup>)



# 数据结构

线性结构

树结构

图结构





### 数组

将一组数据码成一排进行存放，可以通过索引访问数组中的元素

> 数组的索引可是有语义的，也可以是没有的
>
> 为了发挥数组快速查询的优点，一般在索引有语义的情况下使用数组



### 栈

一种线性的结构，相对数组而言操作更加少，可以认为它是数组的子集

只能由一端写入和读取元素

数据后进先出



### 队列

一种线性的结构，相对数组而言，队列的操作是数组的子集

只能从队尾添加元素，队首提取元素

数据先进先出



##### 数组队列的局限性

数组队列的出队操作基于可变数组的删除操作，每次删除元素后面的元素要向前移动，其时间复杂度为 `O(n)` 

> 面对大规模的数据实现时，实现的效率较慢



##### 循环队列

实现出队操作，保证队中元素不移动

循环队列需要浪费一个元素的空间进行条件判断 `tail + 1 % length = head`



循环队列代码优化

- 使用 `size` 变量节约一个空间
- 浪费一个空间不适用 `size` 变量



##### 双端队列

可以在队列的两端添加和删除元素



### 链表

真正意义上的动态数据结构，涉及到引用的概念；有利于递归机制的使用

数据存储在 `Node` 节点中

实现真正的动态，不需要固定容量；丧失随机访问的能力；链表不适合应对索引有语义的情况



##### 链表实现栈

链表对于头节点的操作时间复杂度为 `O(1)`



##### 链表实现队列

链表对链表末尾元素进行操作的时间复杂度为 `O(n)`，为了提高代码的运行效率，对链表的数据结构进行改进，引入一个变量记录链表尾元素



##### 链表和动态数组的性能问题

虽然链表的主要操作是在链表头添加元素，时间复杂度为 `O(1)` ，但是当数据量达到一定程度上，链表的性能更加差。链表的每一次操作都是和内存相关，一般而言，对于内存的操作是很慢的；而对于动态数组的扩容功能其触发的条件会随数据规模增大而减少触发的次数。

> 数组拷贝操作远快于内存操作



### 树结构

树结构是一种天然的组织结构，使用树数据结构可以辅助我们实现某些更加快的查找算法



##### 二分搜索树

- 有唯一的根节点
- 每个结点最多有两个孩子结点
- 每个节点最多有一个父亲结点

具有天然的递归结构



二分搜索树每个节点的值

- 大于左子树的所有结点的值
- 小于其右子树所有结点的值

> 存储的元素必须具有可比较性



##### 遍历方式

前序遍历：最常使用的遍历方式

中序遍历：中序遍历的结果是顺序的

后序遍历：方便释放内存

> 记住栈来实现



##### 二分搜索树的层序遍历

> 借助队列来实现

广度优先遍历的优点在于可以更快的找到待访问的元素



二分搜索树顺序性，在二分搜索树中很容易的可以取到最值，以及元素的前驱和后继



### 集合 & 映射

高层数据结构，定义相应的接口，具体的底层实现可以是多种多样的



##### 集合

不能存放重复元素

```
// 集合需要实现的接口
Set<E>
void add(E)
void remove(E)
boolean contains(E)
int getSize()
boolean isEmpty()
```

典型应用

- 用户统计
- 词汇量统计

> 使用 `BST` 和 `LinkedList` 底层数据结构实现集合，时间复杂度的区别
>
> `BST` 时间复杂度和二分搜索树的高度有关，时间复杂度为 `O(logn)`
>
> `LinkedList` 每次进行操作之前都需要检查元素存在问题，时间复杂度为 `O(n)`



### 映射（字典）

存储键和值对应的数据结构



### 堆

使用二叉树作为底层实现来实现堆

二叉堆是完全二叉树，堆中节点值总是不大于其父节点的值（最大堆）

二叉堆是基本有序的，可以使用数组来存储二叉堆

```java
parent = (i - 1) / 2
left = i * 2 + 1
right = i * 2 + 2
```

堆化的过程性能要优于依次插入元素

> `O(n)` 和 `O(nlogn)`
>
> 叶子节点大概占总结点的个数的一半，它们不需要任何操作
>
> `n/2 * 0` + `n/4 * 1`  + `n/8 * 2`



### 优先队列

普通的队列先进先出；后进后出

优先队列：出队顺序和入队顺序无关；和优先级相关

> 优先级是动态的

`Java` 标准库中的优先队列，默认实现为最小堆

> `Comparator` 是比较器，`java` 中重要的类，自定义类需要手动的传入 `Comparator` 来决定优先队列如何比较



使用快排和优先队列解决最大几个元素问题

- 快排时间复杂度和空间复杂度更优
- 优先队列不需要一次加载全部元素
  - 数据流，实时计算



# 递归

将原来的问题转变为更小的同一问题

链表具有天然的递归特性

递归的执行过程类似于使用栈的操作方式



### 归并排序

性能 `O(nlogn)`

将数组一分为二，处理两个子数组，再将两个子数组合并称为一个有序的数组

> 归并排序需要借助辅助的空间 



##### 归并排序法的优化

如果待排序的数组为有序的情况下，不执行 `merge` 过程，时间复杂度为 `O(n)` 级别

归并排序法在较小的数据规模上的性能不如插入排序法

在数据量较小的时候使用插入排序法优化归并排序

>  在有些情况下可以使用 `O(n)` 的算法来优化更加高级的算法，在部分语言中可能反而会有些慢（一些脚本语言）



### 快速排序

`partition` 将标顶点放置到正确位置的操作，并返回该值的索引

将数组分为三部分

- 起始元素（标定点）
- 小于标定点的元素
- 大于标定点的元素



普通的快速排序算法对于有序的数组实现较慢，时间复杂度为 O(n<sup>2</sup>)，递归的深度变为了 `n` 因此可能导致栈溢出

>对于归并排序递归深度为 `logn` 一般是不会出现栈溢出的情况

解决方案：

确保每次取到的标定点元素不为数组的最小值，使用随机取定标定点的办法



### 双路排序法

对于普通快排出现相同元素导致快排算法的效率下降，同时可能导致栈溢出

> 使用随机化标定点也无法解决问题



修改快排 `partition` 函数的逻辑，随机选择标定点；将不等于标定点的元素分别存储到标定点的两端



### 三路快排

将元素分为小于，等于，大于三部分



时间复杂度

快速排序算法最坏情况下为 O(n<sup>2</sup>)，但是概率非常的低；是一个随机算法

期望的时间复杂度为 `O(nlogn)`  

> 普通算法时间复杂度看最差的情况：能找到一组数据使得算法 `100%` 恶化
>
> 随机算法：找不到一组数据使得算法 `100%` 恶化



### 冒泡排序

冒泡排序法在生活中的思路不常见

思路：每次比较相邻两个元素



### 希尔排序

基本思路：让数组越来越有序，不能只处理相邻的元素

使得两个元素为一组（元素不相邻）



优化

- 可以将三重循环优化为两重循环
  - 将相间隔的元素依次处理
- 步长优化
  - 只需要保证最终的步长为 `1`，可以使用更加长的步长序列来优化算法




# 查找算法

### 二分查找算法

对于有序是数组才能实现二分查找，思路类似于快速排序算法

时间复杂度为 `O(logn)`



##### 二分查找算法的变种问题

查询大于目标的最小元素

扩大循环不变量的范围，中止条件变为左右索引相等



```java
// 二分查找法及其变种的模板
int l, r;

while(l < r){
    int mid = 上取整/下取整;
    if (data[mid].compareTo(target)){
        
    } else {
        
    }
}

return l;
```



# 其他

### `Stack` 不建议使用

`java` 官方不推荐使用 `Stack`，而应该由`Deque` 接口提供

`stack` 继承了 `Vector` 动态数组，因此 `stack` 数组是有能力在任意位置更改元素的



使用 `mid = l + (r - l) / 2` 对两个相邻的元素取中间值可能导致死循环

解决办法

使用 `mid = l + (r - l + 1) / 2` 对右边界取值



### 排序算法的稳定性

排序前相等的两个元素，排序后相对位置不变

> 对学生成绩进行排序，相等分数的学生前后顺序不变

选择排序是不稳定的

插入排序是稳定的，依赖于具体实现，如果实现方式不同可能导致元素发生大规模跳转

希尔排序不稳定的

冒泡排序法是稳定的

快速排序法不稳定，取随机标定点

堆排序不稳定，将数组作为树来进行交换可能导致元素跳跃

归并排序稳定，元素在 `merge` 中进行交换，元素没有机会跳跃

> 如果算法只有一个域，那么算法稳定与否是没有意义的
>
> 如果多个域同时比较，稳定性失去意义
