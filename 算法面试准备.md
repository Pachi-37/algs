# 算法面试准备

快速排序算法 `O(nlogn)`

##### 数据存在的特征

- 包含大量重复元素
  - 三路排序
- 数据是否近乎有序——银行按时间排序
  - 插入排序
- 数据的取值范围有限——学生成绩
  - 计数排序

##### 要求

- 稳定性
  - 归并排序



##### 算法优化的思路

- 遍历常见的算法思路 
- 遍历常见的数据结构
- 空间换时间（哈希表）
- 预处理（排序）



### 算法时间复杂度

算法的时间复杂度通常是看最差情况来决定的

算法复杂度是用来表示算法性能变化趋势的，所以常数值不重要



### 数据规模的概念

如果想在 `1s` 内解决问题

- `O(n^2)` `10^4`级别数据
- `O(n)` `10^8` 级别数据
- `O(nlogn)` `10^7` 级别数据



##### 循环不变量

在每一轮算法开始时的满足的条件

- 查早算法 `data[i]`
  - `data[0,i]` 中都没找到目标（循环不变量） 

> 循环体：维持循环不变量，如果循环不变量发生改变，那么循环状态将会改变



# 基础排序算法



### 选择排序法

依次将最小的元素取出

```java
	// 借助额外空间实现
	public Integer[] sort(Integer[] data) {

        Integer[] sortedArr = new Integer[data.length];
        int minIndex = 0;

        for (int i = 0; i < sortedArr.length; i++) {
            minIndex = 0;
            for (int j = 1; j < data.length; j++) {
                if (data[minIndex].intValue() > data[j].intValue()) {
                    minIndex = j;
                    break;
                }
            }

            sortedArr[i] = data[minIndex];
            data = compact(data, minIndex);
        }

       return sortedArr;
    }

    private Integer[] compact(Integer[] data, int index) {
        Integer[] compactedArr = new Integer[data.length - 1];
        int cur = 0;

        for (int i = 0; i < index; i++) {
            if (index != i) {
                compactedArr[i] = data[cur++];
            }
        }

        for (int i = index; i < compactedArr.length; i++) {
            index++;
            compactedArr[i] = data[index];
        }

        return compactedArr;
    }

	// 原地排序实现
	public void sort(int[] data) {
        int minIndex = 0;

        for (int i = 0; i < data.length; i++) {
    	    minIndex = i;
        for (int j = i + 1; j < data.length; j++) {
            if (data[minIndex] > data[j]){
                minIndex = j;
            }
            swap(data,i,minIndex);
        }
    }
```

> 使用带约束的泛型来扩展使用范围：
>
> 实现 `<E extends Comparable<E>>`



##### 使用泛型优化代码

```java
 public static <E extends Comparable<E>> void sort(E[] arr) {

        // 选择排序循环不变量为 arr[i..n)未排序 arr[0..i) 已排序
//        for (int i = 0; i < arr.length; i++) {
//
//            // 选择 arr[i..)中最小值的索引
//            int minIndex = i;
//
//            for (int j = i; j < arr.length; j++) {
//                if (arr[j].compareTo(arr[minIndex]) < 0) {
//                    minIndex = j;
//                }
//            }
//
//            swap(arr, i, minIndex);
//        }
        // 选择排序循环不变量为 arr[i..n)已排序 arr[0..i)未排序
        for (int i = arr.length - 1; i > -1; i--) {

            int maxIndex = i;

            for (int j = i; j > -1; j--) {
                if (arr[j].compareTo(arr[maxIndex]) > 0) {
                    maxIndex = j;
                }
            }
            swap(arr, i, maxIndex);
        }
    }
```



### 检验排序工具

```java
public class SortingHelper {

    private SortingHelper() {
    }

    public static <E extends Comparable<E>> boolean isSorted(E[] arr) {

        for (int i = 0; i < arr.length - 1; i++) {
            if (arr[i].compareTo(arr[i + 1]) > 0) {
                return false;
            }
        }
        return true;
    }

    public static <E extends Comparable<E>> void sortTest(String sortName, E[] arr) {

        long startTime = System.nanoTime();

        if (sortName.equals("SelectionSort")) {
            SelectionSort.sort(arr);
        }

        long endTime = System.nanoTime();

        double time = (endTime - startTime) / 1000000000.0;

        if (!SortingHelper.isSorted(arr)) {
            throw new RuntimeException(sortName + " failed");
        }

        System.out.println(String.format("%s , n = %d : %f s", sortName, arr.length, time));
    }
}

```



### 插入排序

每次只处理一个元素，将该元素插入到前面已经排好序的元素中 

> 插入排序永远处理的是之前的元素，它和选择排序法不同：选择排序法处理的元素之后就是元素最终所在的位置



两种不同是实现方式

* 新的元素和已排序的元素依次比较，和比其大的元素依次交换位置
* 找到新元素的待插入点，将元素直接插入



> 插入排序法对于近乎有序的元素进行排序的时间复杂度为 `O(n)`，而对于选择排序法的算法复杂度永远为 O(n<sup>2</sup>)



# 数据结构

线性结构

树结构

图结构





### 数组

将一组数据码成一排进行存放，可以通过索引访问数组中的元素

> 数组的索引可是有语义的，也可以是没有的
>
> 为了发挥数组快速查询的优点，一般在索引有语义的情况下使用数组



### 栈

一种线性的结构，相对数组而言操作更加少，可以认为它是数组的子集

只能由一端写入和读取元素

数据后进先出



### 队列

一种线性的结构，相对数组而言，队列的操作是数组的子集

只能从队尾添加元素，队首提取元素

数据先进先出



##### 数组队列的局限性

数组队列的出队操作基于可变数组的删除操作，每次删除元素后面的元素要向前移动，其时间复杂度为 `O(n)` 

> 面对大规模的数据实现时，实现的效率较慢



##### 循环队列

实现出队操作，保证队中元素不移动

循环队列需要浪费一个元素的空间进行条件判断 `tail + 1 % length = head`



循环队列代码优化

- 使用 `size` 变量节约一个空间
- 浪费一个空间不适用 `size` 变量



##### 双端队列

可以在队列的两端添加和删除元素



### 链表

真正意义上的动态数据结构，涉及到引用的概念；有利于递归机制的使用

数据存储在 `Node` 节点中

实现真正的动态，不需要固定容量；丧失随机访问的能力；链表不适合应对索引有语义的情况



##### 链表实现栈

链表对于头节点的操作时间复杂度为 `O(1)`



##### 链表实现队列

链表对链表末尾元素进行操作的时间复杂度为 `O(n)`，为了提高代码的运行效率，对链表的数据结构进行改进，引入一个变量记录链表尾元素



##### 链表和动态数组的性能问题

虽然链表的主要操作是在链表头添加元素，时间复杂度为 `O(1)` ，但是当数据量达到一定程度上，链表的性能更加差。链表的每一次操作都是和内存相关，一般而言，对于内存的操作是很慢的；而对于动态数组的扩容功能其触发的条件会随数据规模增大而减少触发的次数。

> 数组拷贝操作远快于内存操作



### 递归

将原来的问题转变为更小的同一问题

链表具有天然的递归特性

递归的执行过程类似于使用栈的操作方式



### 归并排序

性能 `O(nlogn)`

将数组一分为二，处理两个子数组，再将两个子数组合并称为一个有序的数组

> 归并排序需要借助辅助的空间 



##### 归并排序法的优化

如果待排序的数组为有序的情况下，不执行 `merge` 过程，时间复杂度为 `O(n)` 级别

归并排序法在较小的数据规模上的性能不如插入排序法

在数据量较小的时候使用插入排序法优化归并排序

>  在有些情况下可以使用 `O(n)` 的算法来优化更加高级的算法，在部分语言中可能反而会有些慢（一些脚本语言）



### 快速排序

`partition` 将标顶点放置到正确位置的操作，并返回该值的索引

将数组分为三部分

- 起始元素（标定点）
- 小于标定点的元素
- 大于标定点的元素



普通的快速排序算法对于有序的数组实现较慢，时间复杂度为 O(n<sup>2</sup>)，递归的深度变为了 `n` 因此可能导致栈溢出

>对于归并排序递归深度为 `logn` 一般是不会出现栈溢出的情况

解决方案：

确保每次取到的标定点元素不为数组的最小值，使用随机取定标定点的办法



### 双路排序法

对于普通快排出现相同元素导致快排算法的效率下降，同时可能导致栈溢出

> 使用随机化标定点也无法解决问题



修改快排 `partition` 函数的逻辑，随机选择标定点；将不等于标定点的元素分别存储到标定点的两端



### 三路快排

将元素分为小于，等于，大于三部分



时间复杂度

快速排序算法最坏情况下为 O(n<sup>2</sup>)，但是概率非常的低；是一个随机算法

期望的时间复杂度为 `O(nlogn)`  

> 普通算法时间复杂度看最差的情况：能找到一组数据使得算法 `100%` 恶化
>
> 随机算法：找不到一组数据使得算法 `100%` 恶化



# 其他

### `Stack` 不建议使用

`java` 官方不推荐使用 `Stack`，而应该由`Deque` 接口提供

`stack` 继承了 `Vector` 动态数组，因此 `stack` 数组是有能力在任意位置更改元素的
