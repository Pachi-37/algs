# 算法面试准备

快速排序算法 `O(nlogn)`

##### 数据存在的特征

- 包含大量重复元素
  - 三路排序
- 数据是否近乎有序——银行按时间排序
  - 插入排序
- 数据的取值范围有限——学生成绩
  - 计数排序

##### 要求

- 稳定性
  - 归并排序



##### 算法优化的思路

- 遍历常见的算法思路 
- 遍历常见的数据结构
- 空间换时间（哈希表）
- 预处理（排序）



### 算法时间复杂度

算法的时间复杂度通常是看最差情况来决定的

算法复杂度是用来表示算法性能变化趋势的，所以常数值不重要



### 数据规模的概念

如果想在 `1s` 内解决问题

- `O(n^2)` `10^4`级别数据
- `O(n)` `10^8` 级别数据
- `O(nlogn)` `10^7` 级别数据



##### 循环不变量

在每一轮算法开始时的满足的条件

- 查早算法 `data[i]`
  - `data[0,i]` 中都没找到目标（循环不变量） 

> 循环体：维持循环不变量，如果循环不变量发生改变，那么循环状态将会改变



# 基础排序算法



### 选择排序法

依次将最小的元素取出

```java
	// 借助额外空间实现
	public Integer[] sort(Integer[] data) {

        Integer[] sortedArr = new Integer[data.length];
        int minIndex = 0;

        for (int i = 0; i < sortedArr.length; i++) {
            minIndex = 0;
            for (int j = 1; j < data.length; j++) {
                if (data[minIndex].intValue() > data[j].intValue()) {
                    minIndex = j;
                    break;
                }
            }

            sortedArr[i] = data[minIndex];
            data = compact(data, minIndex);
        }

       return sortedArr;
    }

    private Integer[] compact(Integer[] data, int index) {
        Integer[] compactedArr = new Integer[data.length - 1];
        int cur = 0;

        for (int i = 0; i < index; i++) {
            if (index != i) {
                compactedArr[i] = data[cur++];
            }
        }

        for (int i = index; i < compactedArr.length; i++) {
            index++;
            compactedArr[i] = data[index];
        }

        return compactedArr;
    }

	// 原地排序实现
	public void sort(int[] data) {
        int minIndex = 0;

        for (int i = 0; i < data.length; i++) {
    	    minIndex = i;
        for (int j = i + 1; j < data.length; j++) {
            if (data[minIndex] > data[j]){
                minIndex = j;
            }
            swap(data,i,minIndex);
        }
    }
```

> 使用带约束的泛型来扩展使用范围：
>
> 实现 `<E extends Comparable<E>>`



##### 使用泛型优化代码

```java
 public static <E extends Comparable<E>> void sort(E[] arr) {

        // 选择排序循环不变量为 arr[i..n)未排序 arr[0..i) 已排序
//        for (int i = 0; i < arr.length; i++) {
//
//            // 选择 arr[i..)中最小值的索引
//            int minIndex = i;
//
//            for (int j = i; j < arr.length; j++) {
//                if (arr[j].compareTo(arr[minIndex]) < 0) {
//                    minIndex = j;
//                }
//            }
//
//            swap(arr, i, minIndex);
//        }
        // 选择排序循环不变量为 arr[i..n)已排序 arr[0..i)未排序
        for (int i = arr.length - 1; i > -1; i--) {

            int maxIndex = i;

            for (int j = i; j > -1; j--) {
                if (arr[j].compareTo(arr[maxIndex]) > 0) {
                    maxIndex = j;
                }
            }
            swap(arr, i, maxIndex);
        }
    }
```



### 检验排序工具

```java
public class SortingHelper {

    private SortingHelper() {
    }

    public static <E extends Comparable<E>> boolean isSorted(E[] arr) {

        for (int i = 0; i < arr.length - 1; i++) {
            if (arr[i].compareTo(arr[i + 1]) > 0) {
                return false;
            }
        }
        return true;
    }

    public static <E extends Comparable<E>> void sortTest(String sortName, E[] arr) {

        long startTime = System.nanoTime();

        if (sortName.equals("SelectionSort")) {
            SelectionSort.sort(arr);
        }

        long endTime = System.nanoTime();

        double time = (endTime - startTime) / 1000000000.0;

        if (!SortingHelper.isSorted(arr)) {
            throw new RuntimeException(sortName + " failed");
        }

        System.out.println(String.format("%s , n = %d : %f s", sortName, arr.length, time));
    }
}

```



### 插入排序

每次只处理一个元素，将该元素插入到前面已经排好序的元素中 

> 插入排序永远处理的是之前的元素，它和选择排序法不同：选择排序法处理的元素之后就是元素最终所在的位置



两种不同是实现方式

* 新的元素和已排序的元素依次比较，和比其大的元素依次交换位置
* 找到新元素的待插入点，将元素直接插入



> 插入排序法对于近乎有序的元素进行排序的时间复杂度为 `O(n)`，而对于选择排序法的算法复杂度永远为 O(n<sup>2</sup>)



# 数据结构

线性结构

树结构

图结构





### 数组

将一组数据码成一排进行存放，可以通过索引访问数组中的元素

> 数组的索引可是有语义的，也可以是没有的
>
> 为了发挥数组快速查询的优点，一般在索引有语义的情况下使用数组



### 栈

一种线性的结构，相对数组而言操作更加少，可以认为它是数组的子集

只能由一端写入和读取元素

数据后进先出



### 队列

一种线性的结构，相对数组而言，队列的操作是数组的子集

只能从队尾添加元素，队首提取元素

数据先进先出
